## Урок 4. Практика по исключениям и взаимодействию с Java

---
## Задача
Продолжаем дорабатывать домашнее задание из предыдущего семинара. За основу берём код решения из предыдущего домашнего задания.

1. Добавьте новую команду export, которая экспортирует добавленные значения в текстовый файл в формате JSON. Команда принимает путь к новому файлу. Например
export /Users/user/myfile.json
2. Реализуйте DSL (предметно ориентированный язык) на Kotlin, который позволит конструировать JSON и преобразовывать его в строку.
3. Используйте этот DSL для экспорта данных в файл.
4. Выходной JSON не обязательно должен быть отформатирован, поля объектов могут идти в любом порядке. Главное, чтобы он имел корректный синтаксис. Такой вывод тоже принимается:
```
[{"emails": ["ew@huh.ru"],"name": "Alex","phones": ["34355","847564"]},{"emails": [],"name": "Tom","phones": ["84755"]}]
```
* Записать текст в файл можно при помощи удобной функции-расширения writeText:
```
File("/Users/user/file.txt").writeText("Text to write")
```
Под капотом она использует такую конструкцию
```
FileOutputStream(file).use {
    it.write(text.toByteArray(Charsets.UTF_8))
}
```

* Пример DSL для создания HTML https://pl.kotl.in/c-mvANGBr

### Решение: simple_notes project

### Исправлено в соответствии с замечания:
1. Не стоит вызывать конструкторы исключений при инициализации argsForValidate. В этом случае в стек трейсе исключения будет стек трейс в момент инициализации, а не в момент вызова throw. В конечном счёте будет непонятно, в каком место оно произошло. В вошем случае лучше обернуть создание исключения в лямбду.
2. Функции isPhoneNumberValid и isEmailValid не зависят от состояния класса AddCommand - их можно вынести в объект-компаньон либо на верхний уровень файла, при этом объявив как private.
3. В вашем случае все классы команд создаются в единственном экземпляре и сохраняются Command.commands. В Котлине для этой цели есть ключевое слово object. Однако AddCommand всё-таки лучше сделать классом, в конструктор которого передаются её параметры. В текущем виде у нас переиспользуется команда, которая была введена в прошлый раз. Это может привести к ошибкам в дальнейшем. Например при изменении кода забыли вызвать isValid, и в AddCommand всегда будут аргументы из первой введённой команды. В commands вторым типом можно положить лямбду на конструктор команды.
4. Command.contacts неразрывно связан с командами. Лучше хранить эту переменныу отдельно и передавать в execute команды. Например, решили написать юнит тесты на команду и подменить Contacts, а он жёстко зашит внутри.
5. people оптимальнее хранить в Map<String, Person> чтобы обеспечить константный доступ к записи по имени.
6. Было бы красивее добавить в Contacts метод, принимающий имя и лямбду, в которой можно работать с объектом класса Person, Таким образом, можно было бы скрыть детали реализации поиска и создания экземпляра класса Person в класс Contacts, а в лямбде просто добавлять email/телефон.
